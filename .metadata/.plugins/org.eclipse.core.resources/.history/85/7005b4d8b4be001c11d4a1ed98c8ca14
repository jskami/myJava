package sort;

public class HeapSort {
	
	// 부모 인덱스를 얻는 함수
	private static int getParent(int child) {
		return (child - 1) / 2;
	}
	
	// 두 인덱스의 원소를 교환하는 함수
	private static void swap(int[] a, int i, int j) {
		int temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
	
	// 힙 만들기
	private static void heapify(int[] a, int parentIdx, int lastIdx) {
		/* 현재 트리에서 부모 노드의 자식 노드 인덱스를 각각 구한다.
		 * 현재 부모 인덱스는 가장 큰 값을 갖고 있다고 가정한다.*/
		int leftChildIdx = parentIdx *2 + 1;
		int rightChildIdx = parentIdx *2 + 2;
		int largestIdx = parentIdx;
		
		/* 왼쪽 자식 노드와 비교
		 * 자식 노드 인덱스가 맨끝 원소 인덱스를 넘어가지 않고
		 * 현재 가장 큰 인덱스보다 왼쪽 자식 노드의 값이 더 큰 경우
		 * 가장 큰 인덱스를 가리키는 largestIdx 를 왼쪽 자식 노드 인덱스로 바꾼다.*/
		if(leftChildIdx < lastIdx && a[largestIdx] < a[leftChildIdx]) {
			largestIdx = leftChildIdx;
		}
		
		/* 오른쪽 자식 노드와 비교
		 * 자식 노드 인덱스가 맨끝 원소 인덱스를 넘어가지 않으면서
		 * 현재 가장 큰 인덱스보다 오른쪽 자식노드의 값이 더 큰 경우
		 * 가장 큰 인덱스를 가리키는 largestIdx를 오른쪽 자식 노드 인덱스로 바꾼다.*/
		if(rightChildIdx < lastIdx && a[largestIdx] < a[rightChildIdx]) {
			largestIdx = rightChildIdx;
		}
		
		/* largestIdx와 부모 노드가 같지 않다면
		 * 위 자식 노드 비교 과정에서 현재 부모 노드보다 큰 노드가 존재한다는 의미
		 * 그렇다면, 자식 노드와 부모 노드를 swap한다.
		 * swap된 자식 노드를 부모 노드로 삼은 서브트리를 검사하도록 재귀호출 한다. */
		if(parentIdx != largestIdx) {
			swap(a, largestIdx, parentIdx);
			heapify(a, largestIdx, lastIdx);
		}
		
		
	}
	
	
	
}
